<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans" 
	   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	   xmlns:context="http://www.springframework.org/schema/context" 
	   xmlns:util="http://www.springframework.org/schema/util"
	   xsi:schemaLocation="
		http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.1.xsd
		http://www.springframework.org/schema/context  http://www.springframework.org/schema/context/spring-context-4.1.xsd
		http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.1.xsd"
	default-lazy-init="true">
	
	<description>Spring Shiro整合配置文件</description>
	
	<!-- 配置Session管理器，用于实现Session共享 start -->
	
	<!-- 自定义实现EnterpriseCacheSessionDAO -->
	<!-- <bean id="customShiroSessionDao" class="com.ssm.security.CustomShiroSessionDao"></bean> -->
	
	<!-- sessionIdCookie的实现,用于重写覆盖容器默认的JSESSIONID -->  
    <bean id="sharesession" class="org.apache.shiro.web.servlet.SimpleCookie">  
        <!-- cookie的name,对应的默认是 JSESSIONID -->  
        <constructor-arg name="name" value="SHAREJSESSIONID" />  
        <!-- jsessionId的path为 / 用于共享jsessionId -->  
        <property name="path" value="/" />  
        <!-- cookie中设置了HttpOnly属性，那么通过js脚本将无法读取到cookie信息，这样能有效的防止XSS攻击 -->
        <property name="httpOnly" value="true"/>  
    </bean> 
	
	<!-- session管理器  -->
	<bean id="sessionManager" class="org.apache.shiro.web.session.mgt.DefaultWebSessionManager">
		<!-- <property name="sessionDAO" ref="customShiroSessionDao"></property> -->
		<!-- 定时清理失效会话, 清理用户直接关闭浏览器造成的孤立会话 -->
		<property name="sessionValidationInterval" value="1800000"></property>
		<property name="sessionIdCookie" ref="sharesession"></property>
	</bean>
	<!-- 配置Session管理器，用于实现Session共享 end -->
	
	
    <!--配置securityManager安全管理器 -->
    <!-- 
    	SecurityManager：安全管理器；即所有与安全有关的操作都会与SecurityManager交互；
		且它管理着所有Subject；可以看出它是Shiro 的核心，它负责与后边介绍的其他组件进行交互
     -->
 	<bean id="securityManager" class="org.apache.shiro.web.mgt.DefaultWebSecurityManager">
        <property name="realm" ref="shiroDbRealm" />
        <property name="rememberMeManager.cookie.maxAge" value="30"/>
        <property name="sessionManager" ref="sessionManager"></property>
    </bean>
    
    <!--配置 CacheManager. 2.1需要加入 ehcache 的 jar 包及配置文件. -->
    <bean id="cacheManager" class="org.apache.shiro.cache.MemoryConstrainedCacheManager"> </bean> 
	
	<!--配置realm 自定义的Realm-->
    <!-- 
    	Shiro 从Realm获取安全数据（如用户、角色、权限），就是说SecurityManager要验证用户身份，
    	那么它需要从Realm获取相应的用户进行比较以确定用户身份是否合法；
		也需要从Realm得到用户相应的角色/权限进行验证用户是否能进行操作；
		可以把Realm看成DataSource ， 即安全数据源 
	-->
    <bean id="shiroDbRealm" class="com.ssm.security.ShiroRealm"></bean>
    
    <!--配置lifecycleBeanPostProcessor，可以自动调用spring ioc 容器中的shiro bean 的生命周期方法  -->
    <!-- 开启Shiro注解的Spring配置方式的beans。在lifecycleBeanPostProcessor之后运行 -->
    <bean id="lifecycleBeanPostProcessor" class="org.apache.shiro.spring.LifecycleBeanPostProcessor" />
    
    <!--启用 IOC 容器中使用 shiro 的注解. 但必须在配置了 LifecycleBeanPostProcessor 之后才可以使用. -->     
    <bean class="org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator"
          depends-on="lifecycleBeanPostProcessor">
          <property name="proxyTargetClass" value="true" />
    </bean>
    
    <!-- Shiro Filter id值和web.xml文件配置的过滤器名称相同 -->
    <bean id="shiroFilter"
        class="org.apache.shiro.spring.web.ShiroFilterFactoryBean">
        <property name="securityManager" ref="securityManager" />
        <!-- 登录页面 -->
        <property name="loginUrl" value="/login.jsp" />
        <!-- 登录成功页面 -->
        <property name="successUrl" value="/WEB-INF/views/home.jsp"/>
        <!-- 没有权限的页面 -->
        <!-- <property name="unauthorizedUrl" value="/unauthorized.jsp"/> -->
        <property name="filters">
            <map>
                <entry key="user" value-ref="sysUserFilter"/>
            </map>
        </property>
      	<!--  
        	配置哪些页面需要受保护. 
        	以及访问这些页面需要的权限. 
        	1). anon 可以被匿名访问
        	2). authc 必须认证(即登录)后才可能访问的页面. 
        	3). logout 登出.
        	4). roles 角色过滤器
        -->
        <property name="filterChainDefinitions">
            <value>
            	<!-- 登录可匿名访问 -->
            	/static/**= anon
            	/ssm/shirologin/** = anon
            	/ssm/logout = logout
            	/login.jsp = anon
            	<!-- 可以通过remberme访问 -->
            	ssm/home = user
                <!-- 其他的需要授权访问authc -->
                /ssm/* = authc
            </value>
        </property>
    </bean>

  	<!-- 开启Shiro注解的Spring配置方式的beans。在lifecycleBeanPostProcessor之后运行 -->
    <bean
        class="org.apache.shiro.spring.security.interceptor.AuthorizationAttributeSourceAdvisor">
        <property name="securityManager" ref="securityManager" />
    </bean>
    
    <!-- shiro为集成spring -->
    <bean class="org.springframework.web.servlet.handler.SimpleMappingExceptionResolver">
        <property name="exceptionMappings">
            <props>
            	<!-- 无权限跳转到登陆页，可自行定义 -->
                <prop key="org.apache.shiro.authz.UnauthorizedException">/ssm/home</prop>
            </props>
        </property>
    </bean>
</beans>